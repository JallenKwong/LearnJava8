# 结论以及Java的未来 #

[1.回顾Java8的语言特性](#回顾java8的语言特性)

[1.1.行为参数化（Lambda以及方法引用）](#行为参数化lambda以及方法引用)

[1.2.流](#流)

[1.3.CompletableFuture](#completablefuture)

[1.4.Optional](#optional)

[1.5.默认方法](#默认方法)

[2.Java的未来](#java的未来)

[2.1.集合](#集合)

[2.2.类型系统的改进](#类型系统的改进)

[2.2.1.声明位置变量](#声明位置变量)

[2.2.2.更多的类型推断](#更多的类型推断)

[2.3.模式匹配](#模式匹配)

[2.4.更加丰富的泛型形式](#更加丰富的泛型形式)

[2.4.1.具化泛型](#具化泛型)

[2.4.2.泛型中特别为函数类型增加的语法灵活性](#泛型中特别为函数类型增加的语法灵活性)

[2.4.3.原型特化和泛型](#原型特化和泛型)

[2.5.对不变性的更深层支持](#对不变性的更深层支持)

[2.6.值类型](#值类型)

[2.6.1.为什么编译器不能对Integer和int一视同仁](#为什么编译器不能对integer和int一视同仁)

[2.6.2.值对象——无论简单类型还是对象类型都不能包打天下](#值对象无论简单类型还是对象类型都不能包打天下)

[2.6.3.装箱、泛型、值类型——互相交织的问题](#装箱泛型值类型互相交织的问题)

[3.写在最后的话](#写在最后的话)

## 回顾Java8的语言特性 ##

### 行为参数化（Lambda以及方法引用） ###

### 流 ###

### CompletableFuture ###

### Optional ###

### 默认方法 ###

## Java的未来 ##

### 集合 ###

### 类型系统的改进 ###

#### 声明位置变量 ####

#### 更多的类型推断 ####

### 模式匹配 ###

### 更加丰富的泛型形式 ###

#### 具化泛型 ####

#### 泛型中特别为函数类型增加的语法灵活性 ####

#### 原型特化和泛型 ####

### 对不变性的更深层支持 ###

### 值类型 ###

#### 为什么编译器不能对Integer和int一视同仁 ####

#### 值对象——无论简单类型还是对象类型都不能包打天下 ####

#### 装箱、泛型、值类型——互相交织的问题 ####

## 写在最后的话 ##

Java 8已经占据了一个非常好的位置，可以暂时歇口气，但这绝不是终点！

